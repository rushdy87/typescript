Typescript
-----------
Types:
  - Easy way to refer to different properties and functions that a value has.
  - In the world of Typescript we hve tow different categories of types:
    1- Primitive Types: number, boolean, void, undefined, string, symbol, null.
    2- Object Types: functions, arrays, classes, objects.
  - We use types everywhere.
q1: What is a type?
answer: An shortcut to refer to the different properties and functions that a value has.
q2: In Typescript, what has a type?
answer: Any value.
q3: Why do we care about types?
answer: They give the Typescript compiler information to analyze our code for errors.
------------
Type Annotations:
  - Type Annotations => Code we add to tell Typescript what type of value that a variable can refers to.
  - Type inference => Typescript try to figure out what type of value that a variable can refers to.
  - Typescript can try to guess at the type of a variable based on what you assign to it.
  - we use Type Annotations in trhee scenarios: (variables.ts line 45)
    1- When the function return the 'Any' type, and we need to clarify the value.
    2- When we declare a variable on one line, then initialze it later.
    3- When we want a variable o have a type that cann't be inferred.

Any Type:
  - A type just like a "string" or "boolean".
  - Means TS has no idia what this is.
  - Avoid variables with "Any" at all costs.
Fixing Any type:
  - add type Annotation.
-------------
Type Annotation with functions:
  - Type Annotation for functions: Code we add to tell Typescript what type pf arguments a function receive and what type of values it will return.
  - Type inference for functions: Typescript tries to figure out what type of value a function will return.
-------------
Arrays in Typescript:
  - each element with very consistent type of value (one a specific type of element).
-------------
Tuples:
  - Array-like strcture where each element represents some property of a record.
-------------
Interfaces:
  - Create a new type, describing the property names and value types of an object.
  - Interface is a structure that defines the contract in your application.
  - Classes that are derived from an interface must follow the structure provided by their interface.
q1: The goal of an interface is to:
answer: DEfine a new type.
q2: Take a look at the following code.  What will Typescript do to decide if coffeeCup is of type Cup ?
    interface Cup {
      volume: number;
      height: number;
    }
    const coffeeCup = {
      volume: 300,
      height: 20
    };
answer: Typescript will iterate through all the properties of the interface and make sure coffeeCup has the same properties with the same type.
q3: Does the pineTree object successfully implement the Tree interface?
    interface Tree {
      height: number;
      name: string;
    }
    const pineTree = {
      height: 1200,
      name: 'pine'
    };
answer: Yes.
q4: Does the washDishes object implement the Todo interface?
interface Todo {
  id: number;
  name: string;
  completed: boolean;
}
const washDishes = {
  id: 'AB20-49CD-11EA-4F2F',
  name: 'Do the dishes',
  completed: false
};
answer: No, because the Todo inference expects id to be a number, but washDishes provided a string.
q5: Does washDishes implement both the Todo and Model interfaces?
interface Todo {
  id: number;
  name: string;
  completed: boolean;
}
interface Model {
  id: number;
}
const washDishes = {
  id: 20,
  name: 'Do the dishes',
  completed: false
};
answer: Yes, because washDishes has all the same property names and types of Todo and Model.